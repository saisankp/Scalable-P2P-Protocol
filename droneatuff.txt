import asyncio
import json
import time
import socket

device_name = "Drone-2"
device_ip = "localhost"
device_port = 33500

discovery_ip = "localhost" 
discovery_port = 33333

# devices are stored as device: (ip, port)
knownDevices = {}
forwardingTable = {} # device + "/" + data: address
interestForwards = {} #{} # interest code: address
interestRequests = [] # interest codes generated by this device
dataForwards = {} # interest code: address
requestCode = 0

class DroneNode:
    def __init__(self):
        self.gps = (53, -6) # Latitude, Longitude of TCD
        self.battery_level = 100 # Battery percentage
        self.propeller_speed = 0 # RPM
        self.barometric_pressure = 1013 # hPa (of sea-level)
        self.water_release = False
        self.payload_release = False
        self.speaker_status = False
        self.flashlight_status = False

    def simulate_sensor_data(self): 
            self.gps = (self.gps[0] + 2, self.gps[1] - 1)
            self.battery_level -= 5
            if(self.propeller_speed < 10000):
                self.propeller_speed += 2000
            if(self.barometric_pressure > 920):
                self.barometric_pressure -= 20

    def drone_logic(self):
        if(self.battery_level <= 90):
            print("attempting to contact charger")
            # Try to find a charger
            for device in knownDevices:
                if(device.split("-")[0] == "Charger"):
                    # Send a request to this device
                    send_interest_packet("usage_status", device)



async def discovery():
    discovery_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    discovery_message = device_name
    try:
        # Check if port is available
        discovery_socket.bind((discovery_ip, discovery_port))
        discovery_socket.settimeout(1)
        connection_time = time.time()

        # Hold the connection for 2 seconds to listen for incoming discovery messages
        while time.time() - connection_time < 5:
            try:
                data, sender_address = discovery_socket.recvfrom(1024)
                knownDevices[data.decode()] = sender_address
            except socket.timeout:
                print("Connected to 33333")

        # Close socket to allow other devices to connect
        discovery_socket.close()
    except OSError as e:
        # Send discovery message to the receiver
        device_socket.sendto(discovery_message.encode(), (discovery_ip, discovery_port))
    await asyncio.sleep(3)



# send an interest packet for a piece of data on a different device
def send_interest_packet(data, device):

    global requestCode
    requestCode = requestCode + 1
    packet = "interest"+"/"+str(device_name)+str(requestCode)+"/"+str(device)+"/"+str(data)

    # check if data is in the forwarding table
    if str(device)+"/"+str(data) in forwardingTable:
            device_socket.sendto(packet.encode(), forwardingTable[str(device)+"/"+str(data)])
            #awaitedAcks[str(device_name)+str(requestCode)] = [packet, time.time()]

    # if not perform flooding
    else:
        print(packet)
        for device in knownDevices:
            device_socket.sendto(packet.encode(), knownDevices[device])


def handle_interests(message, address):

    interest_code = message.split('/')[1]
    requested_device = message.split('/')[2]
    requested_data = message.split('/')[3]

    # if this is the requested device, send the info
    if requested_device == device_name:
        send_requested_data(requested_data, address)

    # else forward the packet if it hasnt been already
    elif interest_code not in interestForwards:

        interestForwards[interest_code] = address # add to list of unresolved interests
        print()

        # check if requested data is in forwarding table
        if str(requested_device)+"/"+str(requested_data) in forwardingTable:
            print("sending from table")
            device_socket.sendto(message.encode(), forwardingTable[str(requested_device)+"/"+str(requested_data)])
            #awaitedAcks[interest_code] = [message, time.time()]

        # if not perform flooding
        else:
            for device in knownDevices:
                if knownDevices[device] != address: # dont send the interest back to the sender
                    device_socket.sendto(message.encode(), knownDevices[device])


def handle_data(message, address):

    interest_code = message.split('/')[1]
    requested_device = message.split('/')[2]
    requested_data = message.split('/')[3]

    # add sender to forwarding table
    forwardingTable[str(requested_device)+"/"+str(requested_data)] = address

    # if interest request was made by this device
    if interest_code in interestRequests:
        print("data received")
        del interestRequests[interest_code]

    # if not forward to the correct device
    elif interest_code in interestForwards:
        device_socket.sendto(message.encode(), interestForwards[interest_code])
        #awaitedAcks[interest_code] = [message, time.time()]
        del interestForwards[interest_code]

    # if this data has not been requested perform flooding
    elif interest_code not in dataForwards:
        dataForwards[interest_code] = requested_data
        for device in knownDevices:
                if knownDevices[device] != address: # dont send the interest back to the sender
                    device_socket.sendto(message.encode(), knownDevices[device])


def send_requested_data(requested_data, address):
    print(requested_data)


def receive_messages():
    print("awaiting messages")
    data, sender_address = device_socket.recvfrom(1024)
    print("Received connection: ", sender_address, data.decode())

    # check message is interset request or data
    if data.decode().split('/')[0] == "interest":
        handle_interests(data.decode(), sender_address)

    elif data.decode().split('/')[0] == "data":
        handle_data(data.decode())



device_name = "Drone-2"
device_ip = "localhost"
device_port = 33500

discovery_ip = "localhost" 
discovery_port = 33333

# devices are stored as device: (ip, port)
knownDevices = {}

# bind to device unique port
device_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
device_socket.bind((device_ip, device_port))
print("UDP socket connected")


drone = DroneNode()

async def main():
    while True:
        drone.drone_logic()
        drone.simulate_sensor_data()
        print(drone.battery_level)
        print(knownDevices)
        await asyncio.gather(discovery(), asyncio.sleep(1))

if __name__ == "__main__":
    asyncio.run(main())


