import time
import socket
import threading
import re
import math
import numpy as np
import os

os.system("kill-port 33500")

device_name = "Drone-2"
device_ip = "localhost"
device_port = 33500

discovery_ip = "localhost" 
discovery_port = 33333

# devices are stored as device: (ip, port)
knownDevices = {}
forwardingTable = {} # device + "/" + data: address
interestForwards = {} #{} # interest code: address
interestRequests = {} # interest codes generated by this device
dataForwards = {} # interest code: address
DataReceived = {} # intereset code: data
requestCodeNum = 0

class DroneNode:
    def __init__(self):
        self.destination = (0,0)
        self.charging = False
        self.nearest_charger = ""
        self.gps = (0, 0) # Latitude, Longitude of TCD
        self.battery_level = 100 # Battery percentage
        self.propeller_speed = 0 # RPM
        self.barometric_pressure = 1013 # hPa (of sea-level)
        self.water_release = False
        self.payload_release = False
        self.speaker_status = False
        self.flashlight_status = False

    def simulate_sensor_data(self):
        while True:
            self.update_gps()
            print(self.gps)

            if not self.charging:
                self.battery_level -= 5
            else: 
                self.battery_level += 20
                if self.battery_level >= 100:
                    print("fully charged")
                    self.charging = False
                    self.destination = (0,0)

            if(self.propeller_speed < 10000):
                self.propeller_speed += 2000

            if(self.barometric_pressure > 920):
                self.barometric_pressure -= 20
            time.sleep(2)
    
    def update_gps(self):
        # Move towards destination if not already there
        if math.sqrt((self.gps[0] - self.destination[0])**2 + (self.gps[1] - self.destination[1])**2) > 1:
            print("current destination:", self.destination)
            angle = math.atan2(self.destination[1] - self.gps[1], self.destination[0] - self.gps[0])
            distance = math.sqrt((self.destination[0] - self.gps[0])**2 + (self.destination[1] - self.gps[1])**2)

            # Calculate step sizes based on distance
            step_size = min(10, distance)
            step_x = step_size * math.cos(angle)
            step_y = step_size * math.sin(angle)

            # Update coordinates
            self.gps = (self.gps[0] + step_x, self.gps[1] + step_y)

    def drone_logic(self):
        while True:
            if(self.battery_level <= 80):
                if self.charging == False:
                    available_charger_locations = []
                    
                    # Try to find a charger
                    for device in knownDevices:
                        if(device.split("-")[0] == "Charger"):
                            # Send a request to this device
                            usage_status_code = send_interest_packet("usage_status", device)
                            usage_voltage_code = send_interest_packet("voltage", device)
                            temperature_code = send_interest_packet("temperature", device)
                            locking_actuator_code = send_interest_packet("locking_actuator_status", device)
                            time.sleep(.5)

                            # if charger is available, get gps
                            if usage_status_code in DataReceived and usage_voltage_code in DataReceived and temperature_code in DataReceived and locking_actuator_code in DataReceived:
                                if DataReceived[usage_status_code] == "False" and DataReceived[usage_voltage_code] == "17" and int(DataReceived[temperature_code]) < 40 and DataReceived[locking_actuator_code] == "False":
                                    code = send_interest_packet("gps", device)
                                    time.sleep(.5)

                                    if code in DataReceived:
                                        # extract numbers from string
                                        location = re.findall(r'-?\d+\.\d+|-?\d+', DataReceived[code])
                                        available_charger_locations.append([float(i) for i in location])
                                    

                    if len(available_charger_locations) > 0:
                        self.destination = get_min_distance(available_charger_locations, self.gps)
                        print("here")
                        # if the drone is at the charger
                    if not math.sqrt((self.gps[0] - self.destination[0])**2 + (self.gps[1] - self.destination[1])**2) > 1 and self.destination != (0,0):
                        self.charging = True
                        print("charging..", self.battery_level, "%")

                # if the drone is charging
                else: 
                    print("charging..", self.battery_level, "%")


                #print("current destination:", self.destination)

            time.sleep(2)

def get_min_distance(locations, drone_position):
    distances = []
    for point in locations:
        distances.append(math.sqrt((int(drone_position[0]) - int(point[0]))**2 + (int(drone_position[1]) - int(point[1]))**2))
    return locations[np.argmin(distances)]


def discovery():
    while True:
        discovery_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        discovery_message = device_name
        try:
            # Check if port is available
            discovery_socket.bind((discovery_ip, discovery_port))
            discovery_socket.settimeout(1)
            connection_time = time.time()

            # Hold the connection for 2 seconds to listen for incoming discovery messages
            while time.time() - connection_time < 2:
                try:
                    data, sender_address = discovery_socket.recvfrom(1024)
                    knownDevices[data.decode()] = sender_address
                except socket.timeout:
                    continue

            # Close socket to allow other devices to connect
            discovery_socket.close()
        except OSError as e:
            # Send discovery message to the receiver
            device_socket.sendto(discovery_message.encode(), (discovery_ip, discovery_port))

        time.sleep(1)


# send an interest packet for a piece of data on a different device
def send_interest_packet(data, device):
    global requestCodeNum
    requestCodeNum = requestCodeNum + 1
    requestCode = str(device_name)+str(requestCodeNum)

    packet = "interest"+"/"+requestCode+"/"+str(device)+"/"+str(data)
    interestRequests[requestCode] = [str(device), str(data)]

    # if no specific devices are mentioned in the call
    if device == "none":
        # check if data is in the forwarding table
        if str(device)+"/"+str(data) in forwardingTable:
                device_socket.sendto(packet.encode(), forwardingTable[str(device)+"/"+str(data)])
                #awaitedAcks[requestCode] = [packet, time.time()]

        # if not perform flooding
        else:
            for devices in knownDevices:
                device_socket.sendto(packet.encode(), knownDevices[devices])

    else:
        device_socket.sendto(packet.encode(), knownDevices[device])

    return requestCode


def handle_interests(message, address):

    interest_code = message.split('/')[1]
    requested_device = message.split('/')[2]
    requested_data = message.split('/')[3]

    # if this is the requested device, send the info
    if requested_device == device_name:
        send_requested_data(message, address)

    # else forward the packet if it hasnt been already
    elif interest_code not in interestForwards:

        interestForwards[interest_code] = address # add to list of unresolved interests

        # check if requested data is in forwarding table
        if str(requested_device)+"/"+str(requested_data) in forwardingTable:
            print("sending from table")
            device_socket.sendto(message.encode(), forwardingTable[str(requested_device)+"/"+str(requested_data)])
            #awaitedAcks[interest_code] = [message, time.time()]

        # if not perform flooding
        else:
            for device in knownDevices:
                if knownDevices[device] != address: # dont send the interest back to the sender
                    device_socket.sendto(message.encode(), knownDevices[device])


def handle_data(message, address):

    interest_code = message.split('/')[1]
    requested_device = message.split('/')[2]
    requested_data = message.split('/')[3]

    # add sender to forwarding table
    forwardingTable[str(requested_device)+"/"+str(requested_data)] = address

    # if interest request was made by this device
    if interest_code in interestRequests:
        #print("data received:", message)
        DataReceived[interest_code] = requested_data
        del interestRequests[interest_code]

    # if not forward to the correct device
    elif interest_code in interestForwards:
        device_socket.sendto(message.encode(), interestForwards[interest_code])
        #awaitedAcks[interest_code] = [message, time.time()]
        del interestForwards[interest_code]

    # if this data has not been requested perform flooding
    elif interest_code not in dataForwards:
        dataForwards[interest_code] = requested_data
        for device in knownDevices:
                if knownDevices[device] != address: # dont send the interest back to the sender
                    device_socket.sendto(message.encode(), knownDevices[device])


def send_requested_data(message, address):
    interest_code = message.split('/')[1]
    requested_device = message.split('/')[2]
    requested_data = message.split('/')[3]

    data_response = "data"+"/"+str(interest_code)+"/"+str(requested_device)+"/"+str(getattr(drone, requested_data))

    device_socket.sendto(data_response.encode(), address)


def receive_messages():
    while True:
        print("awaiting messages")
        try:
            data, sender_address = device_socket.recvfrom(1024)
            #print("Received connection: ", sender_address, data.decode())

            # check message is interset request or data
            if data.decode().split('/')[0] == "interest":
                handle_interests(data.decode(), sender_address)

            elif data.decode().split('/')[0] == "data":
                handle_data(data.decode(), sender_address)

        except ConnectionResetError as e: continue



device_name = "Drone-2"
device_ip = "localhost"
device_port = 33500

discovery_ip = "localhost" 
discovery_port = 33333

# devices are stored as device: (ip, port)
knownDevices = {}

# bind to device unique port
device_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
device_socket.bind((device_ip, device_port))
print("UDP socket connected")


drone = DroneNode()

def main():

    sensor_data_thread = threading.Thread(target=drone.simulate_sensor_data)
    drone_logic_thread = threading.Thread(target=drone.drone_logic)
    discovery_thread = threading.Thread(target=discovery)
    receive_messages_thread = threading.Thread(target=receive_messages)

    sensor_data_thread.start()
    drone_logic_thread.start()
    discovery_thread.start()
    receive_messages_thread.start()

    #while True:
        #drone.drone_logic()
        #drone.simulate_sensor_data()
        #print(drone.battery_level)
        #print(knownDevices)
        #await asyncio.gather(discovery(), asyncio.sleep(1))

if __name__ == "__main__":
    main()
