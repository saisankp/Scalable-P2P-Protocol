import os
import socket
import threading
import asyncio
import time
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

os.system("kill-port 33502")

device_name = "Charger-1"
device_ip = "localhost"
device_port = 33503

discovery_ip = "localhost"
discovery_port = 33333

# devices are stored as device: (ip, port)
knownDevices = {}
forwardingTable = {}  # device + "/" + data: address
interestForwards = {}  # interest code: address
interestRequests = []  # interest codes generated by this device
dataForwards = {}  # interest code: address
requestCode = 0

# ECC key pair generation
private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
public_key = private_key.public_key()

# Serialization of ECC public key
ecc_public_key_bytes = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
)

# bind to device unique port
device_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
device_socket.bind((device_ip, device_port))
print("UDP socket connected")

class DroneChargerNode:
    def __init__(self):
        self.gps = (70, -2)  # Latitude, Longitude near TCD
        self.voltage = 0  # Volts
        self.temperature = 10  # Degrees Celsius
        self.solar_power_charging_rate = 0  # Wh/m
        self.usage_status = False
        self.locking_actuator_status = False
        self.fire_alarm_sensor = False
        self.rfid_authenticator_output = None

    def simulate_sensor_data(self):
        # GPS does not change unless it is being transported
        self.voltage = 17
        # Temperature does not change unless there is a fire/stress on power
        self.solar_power_charging_rate = 960
        # Usage status only changes when it is confirmed to be charging
        # Locking actuator status changes when it is confirmed to have a drone on it
        # Fire alarm sensor doesn't change unless there is a fire
        # RFID Authenticator needs to be implemented for SECURITY/ENCRYPTION later on (after networks stuff)

# ECC encryption and decryption functions
def encrypt_data(public_key, plaintext):
    iv = os.urandom(16)  # Initialization vector
    cipher = Cipher(algorithms.ChaCha20(iv), mode=modes.CFB8(), backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(plaintext.encode()) + encryptor.finalize()
    return iv + ciphertext

def decrypt_data(private_key, encrypted_data):
    iv = encrypted_data[:16]
    ciphertext = encrypted_data[16:]
    cipher = Cipher(algorithms.ChaCha20(iv), mode=modes.CFB8(), backend=default_backend())
    decryptor = cipher.decryptor()
    plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    return plaintext.decode()

def discovery():
    while True:
        discovery_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        discovery_message = encrypt_data(public_key, device_name)
        try:
            # Check if port is available
            discovery_socket.bind((discovery_ip, discovery_port))
            discovery_socket.settimeout(1)
            connection_time = time.time()

            # Hold the connection for 2 seconds to listen for incoming discovery messages
            while time.time() - connection_time < 5:
                try:
                    data, sender_address = discovery_socket.recvfrom(1024)
                    knownDevices[decrypt_data(private_key, data)] = sender_address
                except socket.timeout:
                    continue

            # Close socket to allow other devices to connect
            discovery_socket.close()
        except OSError as e:
            # Send discovery message to the receiver
            device_socket.sendto(discovery_message, (discovery_ip, discovery_port))
        time.sleep(3)

def send_interest_packet(data, device):
    global requestCode
    requestCode = requestCode + 1
    interest_data = "/".join([str(device_name) + str(requestCode), str(device), str(data)])
    packet = "interest" + "/" + interest_data
    encrypted_data_packet = encrypt_data(public_key, packet)

    # check if data is in the forwarding table
    if str(device) + "/" + str(data) in forwardingTable:
        device_socket.sendto(encrypted_data_packet, forwardingTable[str(device) + "/" + str(data)])
    # if not, perform flooding
    else:
        for device in knownDevices:
            device_socket.sendto(encrypted_data_packet, knownDevices[device])

def handle_interests(message, address):
    encrypted_data = message.split('/')[1]
    decrypted_data = decrypt_data(private_key, encrypted_data)
    interest_code, requested_device, requested_data = decrypted_data.split('/')

    # if this is the requested device, send the info
    if requested_device == device_name:
        send_requested_data(decrypted_data, address)
    # else forward the packet if it hasn't been already
    elif interest_code not in interestForwards:
        interestForwards[interest_code] = address  # add to list of unresolved interests
        # check if requested data is in forwarding table
        if str(requested_device) + "/" + str(requested_data) in forwardingTable:
            device_socket.sendto(message.encode(), forwardingTable[str(requested_device) + "/" + str(requested_data)])
        # if not, perform flooding
        else:
            for device in knownDevices:
                if knownDevices[device] != address:  # don't send the interest back to the sender
                    device_socket.sendto(message.encode(), knownDevices[device])

def handle_data(message, address):
    encrypted_data = message.split('/')[1]
    decrypted_data = decrypt_data(private_key, encrypted_data)
    interest_code, requested_device, requested_data = decrypted_data.split('/')

    # add sender to forwarding table
    forwardingTable[str(requested_device) + "/" + str(requested_data)] = address

    # if interest request was made by this device
    if interest_code in interestRequests:
        print("data received")
        del interestRequests[interest_code]

    # if not, forward to the correct device
    elif interest_code in interestForwards:
        device_socket.sendto(message.encode(), interestForwards[interest_code])
        del interestForwards[interest_code]

    # if this data has not been requested, perform flooding
    elif interest_code not in dataForwards:
        dataForwards[interest_code] = requested_data
        for device in knownDevices:
            if knownDevices[device] != address:  # don't send the interest back to the sender
                device_socket.sendto(message.encode(), knownDevices[device])

def send_requested_data(message, address):
    interest_code = message.split('/')[1]
    requested_device = message.split('/')[2]
    requested_data = message.split('/')[3]

    data_response = "data"+"/"+str(interest_code)+"/"+str(requested_device)+"/"+str(getattr(charger, requested_data))
    encrypted_response = encrypt_data(public_key, data_response)
    device_socket.sendto(encrypted_response, address)

def receive_messages():
    while True:
        print("awaiting messages")
        data, sender_address = device_socket.recvfrom(1024)
        print("Received connection: ", sender_address, data.decode())

        # Check if the received message is an encrypted interest or data
        if data.decode().split('/')[0] == "interest":
            handle_encrypted_interest(data.decode(), sender_address)
        elif data.decode().split('/')[0] == "data":
            handle_encrypted_data(data.decode(), sender_address)
        else:
            print("Unknown message type")

def handle_encrypted_interest(encrypted_message, address):
    decrypted_data = decrypt_data(private_key, encrypted_message.split('/')[1])
    handle_interests(decrypted_data, address)

def handle_encrypted_data(encrypted_message, address):
    decrypted_data = decrypt_data(private_key, encrypted_message.split('/')[1])
    handle_data(decrypted_data, address)


charger = DroneChargerNode()

async def test():
    print("test!!!!")

def main():
    sensor_data_thread = threading.Thread(target=charger.simulate_sensor_data)
    discovery_thread = threading.Thread(target=discovery)
    receive_messages_thread = threading.Thread(target=receive_messages)

    sensor_data_thread.start()
    discovery_thread.start()
    receive_messages_thread.start()

if __name__ == "__main__":
    main()
